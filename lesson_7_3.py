# 3) Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо# создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий# количеству ячеек клетки (целое число). В классе должны быть реализованы методы# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()),# умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только# к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением# до целого) деление клеток, соответственно.# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться# сумме ячеек исходных двух клеток.# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как# произведение количества ячеек этих двух клеток.# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как# целочисленное деление количества ячеек этих двух клеток.# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и# количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n# равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний# ряд записываются все оставшиеся.# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод# make_order() вернет строку: *****\n*****\n**.# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод# make_order() вернет строку: *****\n*****\n*****.class Cell:    def __init__(self, cells):        self.cells = cells    def __str__(self):        return str(f'Number of cells - {self.cells}')    def __add__(self, other):        return Cell(self.cells + other.cells)    def __sub__(self, other):        if self.cells - other.cells > 0:            return Cell(self.cells - other.cells)        else:            print('Error! The difference in the number of cells of two cells is less than or equal to zero.')    def __mul__(self, other):        return Cell(self.cells * other.cells)    def __truediv__(self, other):        return Cell(self.cells // other.cells)    def make_order(self, cells_in_row):        rows = self.cells // cells_in_row        remainder = self.cells % cells_in_row        return ('*' * cells_in_row + '\n') * rows + '*' * remaindercell1 = Cell(10)cell2 = Cell(15)print(f"{cell1} \n{cell1.make_order(3)}")print(f"{cell2} \n{cell2.make_order(5)}")print(f"{cell1 + cell2} \n{(cell1 + cell2).make_order(4)}")print(f"{cell2 - cell1} \n{(cell2 - cell1).make_order(7)}")print(f"{cell1 * cell2} \n{(cell1 * cell2).make_order(50)}")print(f"{cell2 / cell1} \n{(cell2 / cell1).make_order(5)}")